package patterns.structuralDesignPatterns.flyweightPattern;

//Шаблон проектирования Приспособленец — это структурный шаблон в компьютерном программировании,
// который позволяет эффективно использовать большое количество объектов путем совместного использования объектов,
// имеющих сходное состояние. Это достигается путем создания одного экземпляра объектов и его совместного использования
// различными объектами с одинаковыми свойствами. Общий объект называется «приспособленцем» и
// действует как неизменяемый и совместно используемый экземпляр. Остальные объекты сохраняют состояние,
// отличающее их друг от друга, которое обычно сохраняется извне. Этот шаблон часто используется в
// приложениях с большим количеством объектов, где стоимость создания экземпляра каждого объекта высока,
// а объекты можно сгруппировать на основе общих атрибутов.

public class FlyweightPatternDemo {
    private static final String colors[] = {"Red", "Green", "Blue", "White", "Black"};

    public static void main(String[] args) {
        for (int i = 0; i < 20; ++i) {
            Circle circle = (Circle) ShapeFactory.getCircle(getRandomColor());
            circle.setX(getRandomX());
            circle.setY(getRandomY());
            circle.setRadius(100);
            circle.draw();
        }
    }

    private static String getRandomColor() {
        return colors[(int)(Math.random()*colors.length)];
    }

    private static int getRandomX() {
        return (int)(Math.random()*100 );
    }

    private static int getRandomY() {
        return (int)(Math.random()*100);
    }
}

//В этом примере ShapeFactory класс отвечает за создание и поддержку приспособленцев. Когда Circle объект
// запрашивается у фабрики, она сначала проверяет, не создал ли уже объект того же цвета. Если это так,
// он возвращает существующий объект вместо создания нового. Таким образом, количество
// Circle создаваемых объектов сводится к минимуму, а использование памяти оптимизируется.

//Использование шаблона наилегчайшего веса
//Когда приложение использует количество объектов
//Когда стоимость хранения высока из-за количества объектов.
//Когда приложение не зависит от идентификатора объекта.